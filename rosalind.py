import math
import itertools
import re

def count_nucleotides(s):
	"""Description here"""
	return s.count('A') + ' ' + s.count('C') + ' ' + s.count('G') + ' ' + s.count('T')

#sequence = "CCTGAGAACGCTACAGCGGCGAGCGACGTACAGGCAAGGAGGCTACTGAGTACATTTATGTTGATTCTATACAATGGTCGTCACAATAATAGGACACCCCCATAAAGTGGCAAGTTAGTTAGGTGGGGGTTAATTAGCCCCGGTGAGGCCCCGCCACGAGCCTTAATCCATAGGTACTTAAGGCCGTACACGAGAGATAGCGCTCTCCATTACAGCTCTTCTACAACGCACCTAAAGCCGGAAAAGGCGAGCACATTTGCTAGGCGGGCCGAAGTCTCTCCCGGCAGTCAGTTATAAAAATCATTCAATCTAGCAAACGCTGAATTTGCCAAACCCGTCTTTAAAGCTAATTGTTCGGCTTCAGCTATCGACATCCGCACGGGTCGGAAAATAGATTGTCGGAAGTGTGCGAACGGTGACCCTATGGCCACCCCTTAGATACGTATACGCTGGCCTATAAGCTAGGAGAGCAGGTGTAAAGGTCCACTCGGATGCTTTGAGACCCACTTCCTGACGTGGCCAAGATGAAGGGCACAATTCGCTGCCAAGTTCCAATGTCATCCGATGTGGTAGGCGCACTCCGGCCGTATCCCTGTGTTGTAGGCAACTATAACTAGATGGGAGTCCCGTTTACCTCATTTCCAGGATTGCACTCTCAGCTCTCCATGGAGCACTTTTTCTCTTTCGTCAACGGAAAAGCGACTCCCGGGGCCAGTGGCAGAATTTTGGTCAGTGATTACGCCTAGGTAATGGTGGGGTGGCGAGCTTCATCTTTTCGCAGCCTGGTCGCGGAGTGAGAAACGGTTGGCGAAGTTTCAGGGAGGCCACGCAGATAATCGTCCCCGGGGAATTCTGCGCACATGCCCTTTGGACAGCATCGGATTGGACTAGGTTTGCAAAATGAGAAGCGCCACTAG"
#print(count_nucleotides(sequence))

def transcribe(dnastring):
	"""Description here"""
	rnastring = ""
	for c in dnastring:
		if c == "T":
			rnastring += "U"
		else:
			rnastring += c
	return rnastring

#sequence = "ATTTGAGCTCGTAACCGCAATCATAACACCCAAATGTGATAACGAACGTAAACCGTGGTGAACCCCCGGGCGTCAGTATTCGTCCCACATGCGCGGTAGTCTCTAAAATTCTTAAAATAGGTGAGTCCCTTGGACCCTTCGCTTATCTACCGCTCAGGACCCTGGTCTATGAGTCGACCATCTGGCTTGGTTCGGCTCGAACTAAGACCACGGGCAGTCGCTCATCCTGGGGACCAAGATCCAGGATTCGTAGGACTGACATTACACGAGTGATCTGCCTTAACGTATTGTACGGTGTGGAGTCGCGACAAACAGCATTGAAAAGTCGCGTGCCGCTCCTGGGTAAGGTCAACACTCCCGTAGACGAACCTGCGTCTCGAAGTACGGGTCACCATAACAACTCGGGGTTGCCCAGCTTTTGGCGCGTTCTAGTTAGCTCACGGGGCTTTTTCTCGGTGAACGGAGCAGGAAGATCGCGAGTGCATATCGGTAGAAAGTCAATGCCGTGAGACGGCAGGAGAGATGTGAGGGTGCGCTAACTCGACACCATCGTATGGGAGTAAATCACGCGATACTCACGTTGACTCGTTGTCGCCAATCGTCCCAGGAAGCGTTTCGTGATTGACGATGAGGTCCGGAAGTTCGCCCCCAACGGGGTCTTCCCATCCTGTGCGAGCTTTTTTAGGATCTAGCCAACTTCACATCCTACCTGATTTTTAAAACCAACGGGACTTTTACTCCACACGGGCGTCACTGGCAACTCATGGAATGACCTTCCTGGCCCTATTCCCCCAGCACAAAGGTAGCGGGGAGCGCCCAGGCGAGTTAATAGCCAGGCACCAAGGTCCGTCAGTGATTCCTCGCCCGAGCGACGTTGTTTGCGAGATCCTCGTATCCGGATGGCTCGGATGATAATGTAGAAGCTTCGACTGGGACAGGTCTTTCAAGGGATACTAGCCACTAATATCGG"
#print(transcribe(sequence))

def reverse_complement(dnastring):
	"""Description here"""
	reverse = dnastring[::-1]
	rnastring = ""
	for c in reverse:
		if c == "A":
			rnastring += "T"
		elif c == "T":
			rnastring += "A"
		elif c == "C":
			rnastring += "G"
		elif c == "G":
			rnastring += "C"
	return rnastring

#sequence = "TCGCACTCGCTCGTGCGACCTATTATAAGCCGACGCTCTCTATTGACTTTTGCGTTTTATTTTACGAGGTGGGAATGCTATATGATTCGTCATGCTTGAACGTCTGTGGACAGGATGAAACAAATAGTCACAGTAGGAGGTGCGGCAGCTTTAGAAGCACGTGACTAGGTAATGGCAGCGTATCGCGGGGACGGCGCTCGGCCATCCCTGTGAAATTTAAAATATTGATTTTTATAGGGATTGGCAAATTCCCTTTGCTTGGCGAGCTGCACCGGTAGGATATGTTTTAGAGGCTGTATCAGGACTAGTTAAAACTATAGTATTTAGGCCCGTTCGCTTAGACGGCTCAAGTAAGAAACTAAGCCAGTCAGGTGGGACACAGTTCGCATTGCCTCTGTCGCCACTCTTATAAGCGAGCCCTGAGCATTCTATAGTTTTACTATTCACACTTGAAACTCGTCCGACCTCCTTCGCGCATCACCTGCACATAATCGGGATGACATGAAGCTGTATCGTCCATCTTTTTCCCGAAAACGATGTAAACGTACTTATGCCTGTCGGGCCGTTTCATAAGTCTGGTTCAATGCTTACGAGTTTACTAGACTATACCCTCGCGTGACTTTGAAAGCTCTTGCGCAGGTGCAATCGTAACAATCCCACTGACTCTTGTTGATTAACGGCTTCATCGTAAAGCTTGTAAACTTGGGCCTGGCCAGGTGTCGGAGATCGGGAACTTTGACTAAGACTCCCACATTACCAGTATATTCAAGCTTATACTGAGCGTCGGGTAACAGAAATTCTAAGCCCATTCTAAACTGCCTTATTCTCGGCATGCGGAAAGGGCTTAGGAATCGGAGTTACAAGAGTGAAAATAATCCGATATTTGCGAGTAAGACGGGTCGCCAGTGAGCTCCAGTTCACTAG"
#print(reverse_complement(sequence))

def compute_gc_content(fastafile):
	"""Description here"""
	ratios = {}
	curr_string = ""
	for line in open(fastafile):
		# print line
		# print ratios
		if line[0] == ">":
			if curr_string:
				gcratio = float(gc) / (float(totallen))
				ratios[curr_string] = gcratio
			gc = 0
			totallen=0
			curr_string = line[1:]
		else:
			gc += line.count("G") + line.count("C")
			totallen += len(line) - 1
			# print gc
			# print len(line)
	gcratio = float(gc) / (float(totallen))
	ratios[curr_string] = gcratio
	maxkey = max(ratios, key=ratios.get)
	print ratios[maxkey] * 100

#compute_gc_content("rosalind_gc.txt")

def hamming_distance(s,t):
	"""Description here"""
	i = 0
	count = 0
	if len(s) == len(t):
		while i < len(s):
			if s[i] != t[i]:
				count += 1
			i += 1
	return count

# string1 = "GAAGACAGTGGACCTTGAGGTCTGAAGCTAGAGTCAATATTTGGTGGGTGCAGTCCCGGTACTCCCTATCCAATTATTATAGCCCTGTAGGAACTACGCTAATCTTTGCCTTCAACGGTACAAAGGCTCCACCTGCAGTCGAATCGGTACATGTAGTACAGAGAGAGTGAGTTGTAAGTAGGGATGATCGTCGTCGTGGGTTCTAATACTCAATGTGATCGTCTACGTATCAGTAATTTTTACATTACCCCTGCGCCTACTTCCTGGGGGGTATGTGAAGGTGCCATCCCCGTACTTCTGCGCGGAAGTCTATAATCCCAATATTGCATTCCGCCCTCAAGGACTTCTCAATTTAGTATGATGTGCACACGGGCTCCAACTGCGCTGTAAAGACCGGGACCCGGGCAGGTAATAGGTTCAGCCCAGAGCCCGCATATTCCACTGGGGTGTTGCCAATCTTATTCGGTCCATCGTAGCTAGATCTGAGTCCCCGCGACACAAAGCTTGTTGCGATCGGTAGGACTAGCACTTCTGGACTTGCTTGCCAGCCGAAGTATCAGAAGGTGGACTTTCCTGAACACCTGCGTACGGGACTGAGCCAACCAGTCAAAAGTCAGGGCGGCTATCAGACTAATCTTGAACTGACACGATGCAACTTGCCAATAACGGCAACCGAGTTGAAACCCTCTCCCAACATAAGAGAGCCCCCTCTCTCACTTTTTGAAGCATTTTGAGAAGATATCAACTCAACAAGGAAGTATGTCTAGCCGTTCCCTGTTTGAAACGTCCAAACATCGCGACTCGGTAAAAACAAACGACCGCGGCCTCCGGAACACGTCAATGGTGACGTTCCTAACTAGTAGCTGGGATAACAATTCCCCACAGGTAGCACCTTCTAGTTGTTTAGCCT"
# string2 = "GCAGTGATGGGGTTTAGTTGGCTTAATCTAGAGTCAATATAACGCACAATGAGTCCACAGAGGCGCTATACCCATATACTGCCCTGTTACGCACAACGGAAATCTTCGCCAGCGACGGCAAAAAGGTCACGGCGCAGGGACAGTCAGGAAAATTAATAGTGTGACAGTGAGTTCTAGTAACGGAGGATAGGTGTCATGGCTTCTCTTACGAGATGCGTGCACCCCGGTCACACGTAACACTCCAAGCAACCTGCGCGTACATCGTCGAACGTATACCATGGTGTTCCGCGTTAAAAGCTGGCTGAACGTCGATCATTTAACTGTAATCTACCTAGACGTAGGACATCAATACCCGGAGGAATGGGCACACAAACTGAATTTGGGTGTGAACGACTGTAGTCAGGACAGGTTCTGGCTTCGTATAACAGGTTTGATGATCTACCTGACTTATCCGATGTACATCAGGCTCAGTTCACCTATCACTGTCTCCGGGCGACACATGACTCACTTCTTTTTATAGGTCTCTCATTTCTGGCCCCGCGAACCACCCTAAATAAACGAAGGCATTCCGTAGAAACCAATCAGGCCCGACAATGAGCCAGCCAGCACAAATTGGGTTCCGCCAGCATTCGAATGTAGATTTGATATAATGTGCACTGGCAATCACTTCATTTGGGGGGAGCCTATTTCATCAAGCAGTTAAGGCTCCTCGCTAAGTATATGAAGCATGTGACAAACTAAACGAGTCAACGAGGCCGGCTAGCGTACCTGTGCCAGTTCCAAACCTCTACTCTTCGAGACACGACAAACACAAAACAGCGTGGGTCCAAGCGCAGAAAAAGGGTGGTCTTCCTAGCTATTAGCTATTACTCCAAGTACTGAACTATCCCACCTGGATGGAGTGTAGCAA"

#print(hamming_distance(string1, string2))

def recurrence_rabbits(n,k):
	"""Description here"""
	curr = 1
	next = 1
	i = 2
	while i < n:
		temp = curr
		curr = next
		next = curr + k * temp
		i += 1
	return next

# print(recurrence_rabbits(31, 4))

def nCr(n,r):
    f = math.factorial
    return f(n) / f(r) / f(n-r)

def mendel(dd, dr, rr):
	"""Description here"""
	total = dd + dr + rr
	p_rr_rr = float(nCr(rr, 2)) / float(nCr(total, 2))
	p_dr_dr = float(nCr(dr, 2)) / float(nCr(total, 2))
	p_dr_rr = (float(nCr(rr, 1) * nCr(dr, 1))) / float(nCr(total, 2))
	p_offspringisrr = p_rr_rr * 1 + p_dr_dr * 0.25 + p_dr_rr * 0.5
	return 1 - p_offspringisrr

#print(mendel(17,22,24))


# A dictionary of RNA 3-letter codons mapped to the 1-letter protein abbreviation they translate to.
rnacodons = {"UUU":"F", "UUC":"F", "UUA":"L", "UUG":"L",
    "UCU":"S", "UCC":"S", "UCA":"S", "UCG":"S",
    "UAU":"Y", "UAC":"Y", "UAA":"", "UAG":"",
    "UGU":"C", "UGC":"C", "UGA":"", "UGG":"W",
    "CUU":"L", "CUC":"L", "CUA":"L", "CUG":"L",
    "CCU":"P", "CCC":"P", "CCA":"P", "CCG":"P",
    "CAU":"H", "CAC":"H", "CAA":"Q", "CAG":"Q",
    "CGU":"R", "CGC":"R", "CGA":"R", "CGG":"R",
    "AUU":"I", "AUC":"I", "AUA":"I", "AUG":"M",
    "ACU":"T", "ACC":"T", "ACA":"T", "ACG":"T",
    "AAU":"N", "AAC":"N", "AAA":"K", "AAG":"K",
    "AGU":"S", "AGC":"S", "AGA":"R", "AGG":"R",
    "GUU":"V", "GUC":"V", "GUA":"V", "GUG":"V",
    "GCU":"A", "GCC":"A", "GCA":"A", "GCG":"A",
    "GAU":"D", "GAC":"D", "GAA":"E", "GAG":"E",
    "GGU":"G", "GGC":"G", "GGA":"G", "GGG":"G",}

def translate(mrna):
	i = 0
	protein = ""
	while i < len(mrna):
		codon = mrna[i:i+3]
		protein += rnacodons[codon]
		i += 3
	return protein

# sequence = ""
# print(translate(sequence))

def find_motif(dnastring, motif):
	string = "(?=" + motif + ")"
	indexstring = ""
	for item in [m.start() for m in re.finditer(string, dnastring)]:
		indexstring += str(item+1) + " "
	return indexstring

# dnastring = "AATTTCGAATTTCGACCACTTGGATTTCGACCACAATTTCGACATTTCGACATTTCGAGATTTCGAATTTCGAGCTATTTCGAACGATTTCGACGTAATTTCGACAGCATTATTTCGACTGATTTCGAGGAGATTTCGAAATTTCGAATTTCGATTGGATTTCGATAAGAGGCGTCATTTCGACACATTTCGAGCATTTCGAATTTCGAATTTCGAATTTCGAACATTTCGATTAATTTCGACAATTTCGATGCCATTTCGATGCCTGGCATTTCGAGTGATTTCGATGTGTATTTCGAGGATTTCGATCGAATTTCGAAATTTCGAATTTCGATATTTCGAGCCCATTTCGATGATTTCGAGTCCCCCCATTTCGAAATCCTAGAATTTCGACATACATGGCACATTTCGACATTTCGAATTTCGATGCATTTCGATATTTCGAATTTCGAATTTCGAATTTCGAATTTCGAAATTTCGACATTTCGATAATTTCGAAGAATTTCGATTGACAGGGACATTTCGATGATTTCGAATTTCGATGATTTCGAATTTCGATGCACAAATTTCGAAATTTCGACATTTCGAGAATTTCGATTTCCTTAGATTTCGATGGTTATTTCGATATTTCGACAGATTTCGAATTTCGAGTTATCCTAATTTCGAATTTCGAATTTCGAGCGATAAACCCTTGATTTCGATATTTCGAATTTCGAGCACCCATAAAATTTCGAACCCGTTTAACGAGGTGTATTTCGACGCTATTTCGAATTTCGATATTTCGAATTTCGAGTGACTTATTTCGATGATTTCGAGTATTTCGAATTTCGAGTGTCACATTTCGAACGTATCTCATTTCGAAGCTAACTC"
# motif = "ATTTCGAAT"

# print(find_motif(dnastring,motif))

def fasta_parser(fastafile):
	"""Takes a FASTA file as input and returns a list of [label, sequence] pairs."""
	toreturn = []
	key = None
	for line in open(fastafile):
		if line[0] == ">":
			if key:
				toreturn.append([key, value])
			key = line[1:].strip()
			value = ""
		else:
			value += line.strip()
	toreturn.append([key, value])
	return toreturn

# print(fasta_parser("rosalind_cons.txt"))

def consensus_profile(fastafile):
	data = fasta_parser(fastafile)
	nucleotides = ["A", "C", "G", "T"]
	A = []
	C = []
	G = []
	T = []
	i = 0
	while i < len(data[0][1]): # iterate through indices
		counts_i = {}
		for j in data: #iterate through strings
			base = j[1][i] # ith character in string of jth pair
			if base in counts_i:
				counts_i[base] += 1
			else:
				counts_i[base] = 1
		for nuc in nucleotides:
			if nuc in counts_i:
				if nuc == "A":
					A.append(counts_i[nuc])
				elif nuc == "C":
					C.append(counts_i[nuc])
				elif nuc == "G":
					G.append(counts_i[nuc])
				elif nuc == "T":
					T.append(counts_i[nuc])
				counts_i[nuc]
			else:
				if nuc == "A":
					A.append(0);
				elif nuc == "C":
					C.append(0);
				elif nuc == "G":
					G.append(0);
				elif nuc == "T":
					T.append(0);
		i += 1
	A.insert(0,"A")
	C.insert(0,"C")
	G.insert(0,"G")
	T.insert(0,"T")
	lols = [A, C, G, T]
	length = len(A)
	consensus = consensus_string(lols, length)
	print consensus
	for base in lols:
		s = base[0] + ": "
		for num in base[1:]:
			s += str(num) + " "
		print s

def consensus_string(listoflists, length):
	consensus = ""
	i = 1
	while i < length:
		max_value = 0
		max_label = ""
		for l in listoflists:
			if l[i] > max_value:
				max_value = l[i]
				max_label = l[0]
		consensus += max_label
		i += 1
	return consensus

# consensus_profile("rosalind_cons (1).txt")

def expected_offspring(AAAA, AAAa, AAaa, AaAa, Aaaa, aaaa):
	return 2 * ((AAAA * 1) + (AAAa * 1) + (AAaa * 1) + (AaAa * 0.75) + (Aaaa * 0.5) + (aaaa * 0))

# print(expected_offspring(18863, 19124, 18095, 17294, 16670, 19520))

def permutations(n):
	item = 1
	lst = []
	while item <= n:
		lst.append(item)
		item += 1
	permutations = list(itertools.permutations(lst))
	print len(permutations)
	for l in permutations:
		line = ""
		for item in l:
			line += str(item) + " "
		print line

# permutations(5)

def fib(n, m):
	rabbits = [1] + [0]*(n-1)
	i = 1
	while i < n:
		j = 1
		new_rabbits = 0
		while j <= m:
			if j <= i:
				new_rabbits += rabbits[i-j]
			j += 1
		rabbits[i] = new_rabbits
		i += 1
	return rabbits

print(fib(6,3))









